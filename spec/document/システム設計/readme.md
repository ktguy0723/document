# はじめよう！システム設計 要件定義のその後に　羽生章洋

## システム設計とは（1部、2部）
- システム設計：プログラマが理解できるように要件を変換する仕事のこと
- システム設計ですること：要件をアーキテクチャ（フロント、バック、DB）にマッピングすること
  - システム設計の材料として、「要件」と「アーキテクチャ」が必要である
  - 「要件」とは、作ってほしい人と作る人の間の合意事項  
  → プログラマがソフトウェアを完成させるために必要な情報（UI、機能、データ）

## システム設計の詳細（3部）
### 設計順
```plantuml
要件 <= フロント: 期待に応える
フロント <= バック: 期待に応える
バック <= DB: 期待に応える
```
- 順次要求を満たしていく必要があるため、フロント→バック→DBの順に設計する

### フロント層
- UI設計→機能設計の順で行う（上記の設計順と同様の考え）

### フロント層（UI設計）
#### UIデザインは要件定義で実施すべき
- 要件定義担当者が要求を出して、UIデザイナーが検討・提案する  
→ この流れは要件定義の一環である

#### UIデザインの4つの基本原則
- 近接：関連するものを近くに集める
- 整列：すべてのものを意識的に配列する
  - この考えの延長にグリッドデザイン、レスポンシブデザインがある
- 反復（一貫性）：アプリ全体を通してデザインのある特徴を繰り返す
- コントラスト：重要な事項を強調する  

#### UI設計の手順
- 1つのIFDAM図をピックアップし、1-4をIFDAM図にあるUI数分繰り返す
1. 項目をUI上に配置する
    - 接近と整列を意識しながら配置する（反復、コントラストはビジュアルデザイン時でよい）
    - ユーザはこのUIを使うことで何を達成したいかを常に考える
    - 項目名については曖昧さ（重複、言い換えなど）は完全につぶすこと
2. UIの分割・統合を検討する
    - 見やすさ、使いやすさを想像して、実際に描いて分割・統合を行う
    - UIデザインガイドラインにかならず目を通す 
3. 分割・統合に伴う画面遷移・画面間の機能について検討する
4. 画面遷移の変更に伴う操作手順と操作性の検討を行う
    - 画面レイアウトを見比べながら操作手順を確認する
    - 使い勝手が悪い場合、項目配置、画面分割・統合、画面遷移を見直す
    - IFDAM図に修正内容をフィードバックする
- ビジュアルデザインを施す(4つの基本原則、色、フォントなど)
- エラー画面を考える
  - エラー画面に配置すべき項目は、現象（What）、原因（Why）、対応（How）
  - 次の行動がとれるように対応まで定める必要がある
  - そもそもエラー画面を出さずに住む方法を考える（UIで問題解消できないか考える）

#### UI設計と要件定義
- UI設計は要件定義という仕事の一部
  - 操作設計（UI）と業務設計（要件定義）は密接な関係がある
  - UIを通してどのような業務を行うかを検討する必要がある
- システムが提供する機能ではなく、ユーザの行動単位で考える
  - 行動別にUIを用意する
  - 実装がシンプルになり、利用者にとっても明快なUIとなる
- 設計では巨大な万能型を求めるより、シンプルな要素の組み合わせによる系を実現して全体最適を目指すべき

### フロント層（機能設計）
- バック層の機能をきちんと規定するための材料として、フロント層の機能設計をきちんと行う意識が大切
- 機能設計 = コンピュータの行う仕事を定める（プロセス設計）
- 機能設計（プロセス設計）とは、モジュール化を行うこと

#### 機能設計の進め方
1. IFDAM図から機能を1つ取り出す
2. インターフェースを定義する
3. 実装部を定義する

#### インターフェース定義手順
1. 機能名を決める（仕事を定める）
    - 動詞と目的語を明確にする（「何をどうする」動詞主体の言葉で表す）
    - 5歳の子でもわかる表現にする
    - 語尾まで書く（ex: 申請承認→申請を承認する）
    - 受動態ではなく能動態で使う(受動態は意味がぼやける)
    - 否定表現を肯定表現に変更する（否定表現は実装時コードに現れないことがあり、テストができず品質担保が難しい）

2. 入出力を定義する（材料と成果を定める）
    - IOを定めたらデータ項目をグループ化する（データ型を定義する）

#### 実装部定義手順
1. 末端の機能（分割不可能な機能）であるかどうか判断する
    - 分割可能の場合、2
    - 分割不可能の場合、3以降
2. どの末端機能か選択する
    - 末端の機能例
      - リクエスト、レスポンス
      - デリベーション（導出・加工・変換・計算）
      - 判定（Boolean）
      - バリデーション（エラーメッセージ付き）
      - DB連携処理
3. どの制御構文か選択する
    - 順接の制約
      - できることは「ほかのモジュールを呼び出す」だけとする
      - 呼び出すことができるモジュール数は基本的に3つ以下とする(open, main, close)
      - 呼び出すモジュール数は最大5つまでとする
    - 分岐の制約
      - 条件は「判定の末端機能」の呼び出しのみとする
      - 条件分岐はThenのみとし、Elseは使わない（Else条件を明示するため）
    - 反復の制約
      - ループ内でできることは「ほかのモジュールを呼び出す」だけとする
    - フロント層は機械的に順接を選択し、「入力値をチェックする」「サーバを呼び出す」「次UIへの出力に必要なことをする」とテンプレート化する
4. 制御構文の中から呼び出される小分けモジュールを定義する
    - 「入力値をチェックする」：エラー画面の遷移が必要になればIFDAM図に追加する
    - 「サーバを呼び出す」：バック層へ処理を委譲する
- 正常系を書き切り、土台を作ることが大切（異常系はそのあとでよい）

### バック層
- APIで提供する、または、外部サービスを利用することで、アプリケーション価値をコーディネートしていく土台となる
  - クラサバ型との差別点になる
  - DB層も外部サービスの一部になる
- バック層は基本的に機能設計のみである
- 手順はフロント層の機能設計と同じである

### DB層
#### 設計手順
1. バック層がDB層に期待している機能を集める
    - バック層の機能設計が完了している前提が必要である
    - DB層が担う機能は、データ取得、データ保存である
2. 機能ごとにモジュールのインターフェースを定義する
    - 機能名・入力・出力を定義する
    - 手順はフロント層の機能設計（インターフェース設計）と同じである
3. モジュール内で必要になるテーブルを設計する
    - インターフェースに合わせて非正規化したテーブルを一つ決め、正規化する
    - 正規化手順
      1. 項目を列挙する
      2. エンティティ（表）を分ける（リソース系、イベント系）
      3. 各エンティティに項目を割り振る
      4. 繰り返し部分をエンティティと外部化する
      5. IDを入れてエンティティ間のリレーションシップを設定する
4. モジュール内の実装を考える
    - ほぼ実装レベルになるのでポイントのみ記載するのが良い
    - 保存系：重複、Not Found などの例外系
    - 取得系：集計項目、計算式、並び順など
5. 全モジュールのテーブル設計を統合・調整する
    - 3で作成した個別のERDを1つに統合する

### 最終成果物
- フロント層
  - UIレイアウト
  - フロント層のモジュール定義
  - IFDAM図
- バック層
  - バック層のモジュール定義
- DB層
  - DB層のモジュール定義
  - ERD

## 実務(4部)
### マルチサイクルによるスコープ管理
- 大規模プロジェクトでは、スコープが大きすぎてどこから手を付けていいかわからなくなる
- 機能単位ではなく、業務単位で考えることが大切
- 業務単位（インタラクション単位）でシステム設計に落とし込もう
  1. IFDAM図を作成する（業務単位）
  2. インタラクション（UIからイベントが発生して機能を実行質疑のUIまでに至るひとまとまり）を抜き出す
  3. UI設計、機能設計、DB設計を行う
  4. すべてのインタラクションが完了したら次のIFDAM図を作成する（1へ）
  - DBの統合と整理は適時すすめる（まとめて実施しない）

### テスト設計
- 現実的な案
  - 末端機能はユニットテストで実施する
  - 末端機能の呼び出し（制御機能）はユニットテストかインタラクションレベルのテスト（結合試験）を実施する

### 進捗管理
- 進捗率の分子と分母を定量的に定義する
- 完了しているものが着手中になったら原因を明確にする
  - 分母が増えることはある
  - 分子が減るのは分子の定義に誤りがある可能性が高い
- 大切なのは残管理（進捗は単なる結果でしかない）であることを認識する

### 共通化
- 共通化は先に行わない（システム設計後に実施する）
  - 共通化とシステム設計を並行して実行するとデッドロックが発生する

### リプレース作業
- 業務指向設計でリバースエンジニアリングを実施する
- 新規開発という意識で取り組む